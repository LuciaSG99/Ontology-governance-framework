
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ontology Governance Viewer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      padding: 20px;
    }
    .principle {
      background: white;
      border: 1px solid #ccc;
      border-radius: 6px;
      margin-bottom: 20px;
      padding: 15px;
    }
    .principle-header {
      font-weight: bold;
      background-color: #2c3e50;
      color: white;
      padding: 10px;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .requirement-header {
      font-weight: bold;
      background-color: #3498db;
      color: white;
      padding: 10px;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .requirement {
      margin-top: 10px;
      padding-left: 20px;
    }
    .requirement-content, .guideline-content {
      display: none;
      padding: 10px;
      background: #f0f0f0;
      margin-top: 5px;
      border-radius: 4px;
    }
    .guideline {
      margin-top: 10px;
    }
    .guideline .requirement-header {
      background-color: #bdc3c7;
      color: #2c3e50;
    }
    .checkbox-container {
      margin-right: 10px;
    }
    .arrow {
      transition: transform 0.3s;
    }
    .rotated {
      transform: rotate(180deg);
    }
  </style>
</head>
<body>
  <h1>Ontology Governance Model</h1>
  <div class="metadata-form" style="margin-bottom: 30px;">
    <label><strong>Project name:</strong>
        <input type="text" id="project-name-input" placeholder="Enter project name" style="width: 100%; padding: 8px; margin-top: 5px; margin-bottom: 10px;">
    </label><br>
    <label><strong>Description:</strong><br>
        <textarea id="project-description-input" placeholder="Brief description of the project..." style="width: 100%; height: 80px; margin-top: 5px; margin-bottom: 10px;"></textarea>
    </label><br>
    <label><strong>Version:</strong>
        <input type="text" id="version-input" placeholder="e.g. v1.0" style="width: 100%; padding: 8px; margin-bottom: 10px;">
    </label><br>
    <label><strong>Authors:</strong>
        <input type="text" id="authors-input" placeholder="Enter author names" style="width: 100%; padding: 8px; margin-bottom: 10px;">
    </label><br>
    <label><strong>Ontologies applied:</strong>
        <input type="text" id="ontologies-input" placeholder="Enter ontology names" style="width: 100%; padding: 8px; margin-bottom: 10px;">
    </label><br>
    <label><strong>Organization:</strong>
        <input type="text" id="organization-input" placeholder="Institution or group name" style="width: 100%; padding: 8px; margin-bottom: 10px;">
    </label><br>
    <label><strong>Contact:</strong>
        <input type="email" id="contact-input" placeholder="Email or contact info" style="width: 100%; padding: 8px; margin-bottom: 10px;">
    </label><br>
    <label><strong>License:</strong>
        <input type="text" id="license-input" placeholder="e.g. CC-BY 4.0" style="width: 100%; padding: 8px; margin-bottom: 10px;">
    </label>
</div>
  <div id="content"></div>
  <footer>
    <p>Authors: Lucia Sanchez Gonzalez, Maria Poveda Villalon, and Oscar Corcho</p>
    <p>License: <a target="_blank" href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></p>
    <p>How to cite: "Ontology Governance Framework". April 2025. DOI: ontology-framework</p
  </footer>
  <script>
    const governanceModel = [{"principle_id": "P1", "principle_name": "P1 - Availability.", "text_principle": "P1 - Availability.\nThe ontology and its components (e.g., code, documentation, etc.) are available for access and consumption by the intended target users, including both humans and machines.", "requirements": [{"requirement_id": "R1.1", "requirement_name": "R1.1 Location of the resources.", "requirement_text": "R1.1 Location of the resources.\nTo ensure the availability of the ontology and all its resources, it is essential to clearly define where the ontology is hosted and where it is published:\n- Hosting refers to the platform or infrastructure where the ontology and related assets (e.g. documentation, metadata) are stored, maintained, and updated by its authors.\n- Publication refers to the means by which the ontology is made accessible and discoverable by target users, both humans and machines.", "guidelines": [{"guideline_id": "G1.1.1", "guideline_name": "G1.1.1 Where to host your ontology?", "guideline_text": "G1.1.1 Where to host your ontology?\n\nChoosing an platform or infrastructure to host and maintain the ontology files and its related assets (e.g., documentation, requirements) is a critical decision. This location is often the source from which publication platforms retrieve the ontology.\n\nRecommended hosting options include:\n\n- GitHub, GitLab: These platforms provide robust support for collaboration, version control, and integration with ontology engineering tools (e.g., Ontoology). They are particularly suitable for projects where change tracking and user interaction are key. The use of issues and pull requests allows direct interaction with the target users. Example: The FIBO ontology is hosted and maintained on GitHub.\n\n- Institutional servers: Commonly used when ontologies are developed and maintained internally by organizations or research projects with specific infrastructure needs. This option is more recommended if you want to focus more on the project that gives context to the ontologies. Example: The BIMER ontology network is hosted within a dedicated project infrastructure.\n\n- Ontology repositories and portals: Some ontology repositories not only serve as publication platforms but also support hosting. These platforms often support multiple knowledge representation languages and offer services like visualization, SPARQL endpoints, and APIs. This option allows you to have more visibility among the Ontology Engineering community and to have access to tools and services specially created to support the publication and use of these tools. Example: BioPortal allows hosting and direct access to biomedical ontologies.\n\nWhen selecting a hosting option, please consider:\n- Collaboration and versioning needs.\n- Long-term accessibility and sustainability.\n- Integration with publication platforms and ontology engineering tools."}, {"guideline_id": "G1.1.2", "guideline_name": "G1.1.2 Where to publish your ontology?", "guideline_text": "G1.1.2 Where to publish your ontology?\n\nThe publication of an ontology refers to the action of making it discoverable and accessible to its intended users. Although in some cases the hosting and publication locations may coincide (e.g., a public GitHub repository), the publication specifically addresses the external exposure of the ontology.\n\nCommon publication platforms options include:\n\n- Ontology repositories and catalogues: Platforms designed to promote the discoverability and reuse of ontologies. These include:\n      - General-purpose: They do not focus on ontologies from a specific domain. Example: Linked Open Vocabularies (LOV)\n      - Domain-specific: Focused on the publication of ontologies from a specific area of knowledge. Example: OntoPortal repositories such as BioPortal, AgroPortal, EcoPortal, Ontology Lookup Service (OLS) by EMBL-EBI\n\n- Project-specific web pages: Dedicated pages created within the context of specific projects to showcase ontology outputs and documentation.\n\n- General-purpose research data/software repositories: Platforms like Zenodo, which support long-term archiving and citation through DOIs.\n\n- Git repositories (as publication endpoint): Although they are mainly used for development and hosting, GitHub or GitLab can also serve as public access points when adequately documented.\n\nWhen selecting a publication venue, consider:\n1. The intended use of the ontology\n2. The profile and needs of intenteded users\n3. The level of visibility and services required\n\nOntologies can be published in multiple platforms, however, it is necessary to assure that the ontology is updated and that the documentation remains synchronized across all of them."}]}, {"requirement_id": "R1.2", "requirement_name": "R1.2 Licensing conditions.", "requirement_text": "R1.2 Licensing conditions.\nIt MUST be explicitly stated what terms and conditions apply to the access and use of the ontology and its associated resources (e.g., code, documentation).\nClear licensing ensures that users understand whether, how, and under what conditions they can use, modify, or redistribute the ontology. This information should be easy to find and written in a standard, machine-readable format whenever possible.", "guidelines": [{"guideline_id": "G1.2.1", "guideline_name": "G1.2.1 Choosing a license", "guideline_text": "G1.2.1 Choosing a license\n\nTo ensure that the ontology and its assets are used, shared and reused in a corrected way, it is essential to choose a licence that fits your requirements. \nThe authors should make sure that the licence chosen:\n\n- is compliance with their requirements and the intended used of the ontology. For example, if the authors want the ontology to be freely used and distributed across the community, then they should consider permissive licenses such as CC-BY 4.0 (requires attribution) or CC0 1.0 (no restrictions)\n\n- if your ontology reuses other ontologies, make sure that the licence you chose is compatible with the licence these reused ontologies have. \n\nThe most common and widely accepted practice in the ontology community is to use a Creative Commons license (e.g., CC-BY or CC0), as they are specifically designed for content, are well-understood legally, and offer URIs suitable for metadata annotation.\n\n\nIf, due to its requirements, the ontology cannot be published under an open and standard license, it is strongly recommended to publish the terms and conditions of access and reuse in a clear, accessible file (e.g., TERMS.md, LICENSE.txt) and make it available via a stable URL."}]}]}, {"principle_id": "P2", "principle_name": "P2 - Scope.", "text_principle": "P2 - Scope.\nOntologies are expected to have a clearly defined scope, ensuring aligment between their content and purpose. A well-scoped ontology facilitates its discovery and reuse. It should be specific enough to represent its intended domain while remaining flexible enough to support its extension.", "requirements": [{"requirement_id": "R2.1", "requirement_name": "R2.1 Scope statement.", "requirement_text": "R2.1 Scope statement.\nThe scope of the ontology MUST be clearly defined and documented in all the ontology's manifestation (code, documentation, etc.). The ontology title and description should reflect the defined scope to facilitate discovery and selection by the target users.", "guidelines": [{"guideline_id": "G2.1", "guideline_name": "G2.1 Where and how can I declare the scope of my ontology?", "guideline_text": "G2.1 Where and how can I declare the scope of my ontology?\nAs stated in the requirement, the ontology\u2019s scope should be clearly defined and documented across all its manifestations. This includes both machine-readable metadata and human-readable documentation. For that, the following practices are recommended:\n\n1. Including a scope description in the ontology metadata. \nIt is recommended to use these well-known annotations properties:\n\n- DCMI Metadata Terms dct:abstract. Like in a scientific paper, here a brief abstract and explanation of the resource should be added.\n\n- DCMI Metadata Terms dct:description . As the name says, it should be a short description of the resource. \n\n- rdfs:comment . Normally used to add additional information of the resource, although it is normally used for the definition of terms.  \n\n2. Scope in the ontology's title and description. \nTo choose an adequate ontology title is key to ensure that the ontology is easy to find in ontology in catalogues and repositories:\n\n-  It is a good practice to ensure that the title has domain keywords that represent the area of knowledge of the ontology. For example, if the ontology main goal is to represent knowledge from genetics, the title should contain keywords such as \"Genes\" or \"Genetics\". \n\n- It is also recommended to performed first a search in ontology repositories and catalogues to check if there are already existing ontologies with the same possible name. Thinking about the previous example, there is already a well-known ontology called \"Gene Ontology\", so better to avoid this name. \n\nRegarding the ontology description, it is a good practice to:\n- Clearly state the domain the ontology covers\n- Mention who are the intenteded users \n- If applicable, to mention what is in and out of scope"}]}]}, {"principle_id": "P3", "principle_name": "P3 - Documentation.", "text_principle": "P3 - Documentation.\nHuman-readable documentation contributes to promote the transparency, traceability, and understandability of ontologies. This documentation enables diverse users to understand the ontology's content, context and its evolution across its lifecycle.", "requirements": [{"requirement_id": "R3.1", "requirement_name": "R3.1 Embedded documentation.", "requirement_text": "R3.1 Embedded documentation.\nThe ontology MUST include embedded documentation through metadata and annotations, expressed directly in the ontology code.\nThis documentation should be provided at two complementary levels:\n\n 1. Ontology-level metadata (applies to the whole ontology). The metadata allows to gather and show more information about the context of the ontology. More information can be found in Principle 4 - Metadata. The minimum that should be included for documeting the ontology is: \n \n- Ontology name\n- Ontology main namespace URI \n- Ontology preferred prefix: A recommended prefix established by the authors to used by other users when using their ontology. \n- Ontology creator(s): To provide credit to the people who created the ontology. \n- Ontology contributor(s): To credit people who contribute in the ontology development, even if they didn't have a highly important role.\n- License and Copyrights rights: Indicate the conditions of (re)use of the ontology (see Principle 1 - Availability, Requirement 1 Location of the resources).\n- Version IRI of the ontology (see Principle 10 - Maintenance): The IRI that identifies the current version of the ontology.\n- Scope and description of the ontology (see Principle 2 - Scope)\n\n2. Term-level annotations (applies to individual classes and properties): Users should be able to understand all the elements of the ontology in general but also individually. For that, each element MUST have: \n \n- A label: A descriptive and (if possible) unique name asigned to each term. \n\n- A textual definition: Natural language definition that facilitates the understanding of the notion. These are recommended to be unique within the ontology, and they should be avoid ambiguousity. It is also recommended that the individual name of each element must not be used in the definition itself.", "guidelines": [{"guideline_id": "G3.1.1", "guideline_name": "G3.1.1 Ontology-level metadata documentation", "guideline_text": "G3.1.1 Ontology-level metadata documentation\n\nThere are well-known annotations properties used by the community to describe information mentioned in R1 - Embedded documentation:\n\n- Ontology name: a short name of the ontology. From RDF Schema Vocabulary rdfs:label.\n- Ontology main namespace URI: From the VANN vocabulary vann:preferredNamespaceUri\n- Ontology preferred prefix:  From the VANN vocabulary  vann:preferredNamespacePrefix\n- Ontology creator: From the DCMI Metadata Terms dct:creator\n- Ontology contributor(s): From the DCMI Metadata Terms dct:contributor\n- License and Copyrights: From the DCMI Metadata Terms dct:license\n- Version of the ontology: From the OWL 2 Schema Vocabulary owl:versionIRI\n- Scope and description: From the DCMI Metadata Terms dct:abstract and dct:description\n\nThese annotations should be embedded in the ontology code file. More information about ontology metadata can be found at Principle 4 - Metadata. \n\nExample on how a header of an ontology would look like using these annotations:\n\n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix vann: <http://purl.org/vocab/vann/> .\n@prefix dct: <http://purl.org/dc/terms/> .\n\n\n<https://w3id.org/example> rdf:type owl:Ontology ;\n        rdfs:label \"Example Ontology Name\"@en ;\n        vann:preferredNamespaceUri <https://w3id.org/example#> ;\n        vann:preferredNamespacePrefix \"ex\";\n        dct:creator \"Author 1\",\n                                \"Author 2\";\n        dct:contributor \"Contributor 1\",\n                                        \"Contributor 2\";\n        dct:license <https://creativecommons.org/licenses/by/4.0/> ;\n        owl:versionIRI <https://w3id.org/example/1.0.1>;\n        dct:description \"This is the description of the ontology example.\"@en ."}, {"guideline_id": "G3.1.2", "guideline_name": "G3.1.2 How can I described the ontology terms?", "guideline_text": "G3.1.2 How can I described the ontology terms?\n\nEach individual element of an ontology should be understood by the user through its textual definition, which is also embedded in the ontology code. To do so, here are some recommedations:\n\n1. Use well-known annotations properties. There are three main properties that are highly used to defined terms:\n\n- From RDF Schema the annotation rdfs:label to indicate the human-readable version of the name of the term. Sometimes the label of the term can be different from its identifier (see more information in Principle 5 - Identifiers) \n- From SKOS (Simple Knowledge Organization System) the property skos:definition to add the formal definition of the term \n- From RDF Schema the annotation property rdfs:comment to add the formal definition of the term or other type of additional information\n\nIn fact, both rdfs:comment and skos:definition can be used at the same time. In this case, normally skos:definition is used to add the formal definition of the term, and rdfs:comment is used to add additional information, e.g. an example where the term can be used. \n\n2. Reuse well-known sources:\n\nIf applicable, it is recommended to used already existing definitions from standard references for the definition such as terminologies, dictionaries, glossaries, ISO standards, etc. \nWhen aplying this, the original source should be indicated using the annotation from RDF Schema rdfs:isDefinedBy\n\n3. Clear, natural and simple text:\n\nLast but not least, it is important that the definition is well-written in natural language that is understood by domain experts and ontology users. The terms definition should be defined as simple and accurate as possible, trying to avoid circularity (using the term itself in the definition). \n\nExample of documenting a term called \"Protein\":\n\n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix skos: <http://www.w3.org/2004/02/skos/core#> .\n@prefix ex: <https://w3id.org/example> .\n\nex:Protein rdf:type owl:Class ;\n        rdfs:label \"Protein\"@en ;\n        skos:definition \"Linear POLYPEPTIDES that are synthesized on RIBOSOMES and may be further modified, crosslinked, cleaved, or assembled into complex proteins with several subunits. The specific sequence of AMINO ACIDS determines the shape the polypeptide will take, during PROTEIN FOLDING, and the function of the protein.\"@en ;\n        rdfs:comment \"Proteins play a central role in biological processes such as enzymatic catalysis, DNA replication, and cellular signaling.\"@en ;\n        rdfs:isDefinedBy <https://meshb.nlm.nih.gov/record/ui?ui=D011506> ."}]}, {"requirement_id": "R3.2", "requirement_name": "R3.2 External documentation.", "requirement_text": "R3.2 External documentation.\nIn addition to the embedded metadata, external human-readable documentation MUST be created and provided to describe the ontology's context, usage and maintenance:  \n\n- A document describing the all the terms of the ontology. This is a file that collects all the terms documentation embedded in the ontology and that also contains additional information like the scope of the ontology and examples of usage.  \n- Use cases/user stories: Examples describing how and by whom the ontology is intended to be used, explaining which data is going to be represented. \n- Requirements: The document detailing both functional (e.g., a list of Competency Questions) and the non-functional requirements (e.g., the language of the ontology, licesing conditions). \n- Diagrams: Visual representation of the ontology. A common notation should be used to represent the different elements of the ontology. \n- examples of usage\n- SPARQL queries: example queries to show how the ontology can be queried and used.\n- Guidelines and instructions for maintenance (see Principle 10 - Maintenance)", "guidelines": [{"guideline_id": "G3.2.1", "guideline_name": "G3.2.1 Best practices for publishing external ontology documentation", "guideline_text": "G3.2.1 Best practices for publishing external ontology documentation\n\nDocumenting the ontology is hard-working and continuous activity throughout all the ontology\u2019s lifecycle. As the ontology, the documentation is also a evolving resource that reflects the changes, decisions, and developments in the ontology over time. Here are some best practives to generate human-readable documentation:\n\n1. Documentation is an iterative process\n\nDocumentation must accompany the ontology through all its phases (requirements specification, implementation, publication, maintenance, etc). Any change to the ontology (e.g., adding or deprecating elements) should be reflected in the corresponding documentation. This is important not only for the future users, but also for the authors themselves.\n\n2. Choose an appropriate format for documenting and publishing the ontology:\n\nIt is important to document each element of the ontology in a human-readable way since it is not always easy to go through the Turtle or RDF/XML file and understand searching and trying to understand the terms. For that, there are different ways of publishing this information: \n\n- In static documents, such as PDFs or Word files. It is a more conservative and easy to manage option, but it is also a really time-consuming task. \n\n- In interactive HTML pages. Although this can be as a difficult way, in fact there are several tools created by the Semantic Web Community that allows to create this pages from the metadata and annotation properties of the ontology:\n\n         + WIDOCO: Generates comprehensive HTML documentation from ontology metadata and annotations. \n         + LODE: Lightweight and quick HTML renderer for OWL ontologies.\n         + Prot\u00e9g\u00e9OWLDoc: plugin of Prot\u00e9g\u00e9 that allows to export to HTML \n         + Ontoology: Web-based platform that supports validation, documentation, and publication via GitHub.\n\n\n3. Cite the ontology in a formal and persistent way\n\nIf the ontology has been published in a scientific article or as part of a project deliverable, it is recommended to include a proper citation of the resource in the documentation. Use a persistent identifier such as a DOI, and mention it in both the HTML documentation and embedded metadata (e.g., using dct:bibliographicCitation or dct:identifier)."}]}]}, {"principle_id": "P4", "principle_name": "P4 - Metadata.", "text_principle": "P4 - Metadata.\nThe ontology is made findable and traceable through its metadata, which helps users identify and interpret its context.", "requirements": [{"requirement_id": "R4.1", "requirement_name": "R4.1 Metadata at whole ontology level.", "requirement_text": "R4.1 Metadata at whole ontology level.\n \nThe ontology MUST include a minimal set of metadata annotations at the ontology level to ensure its discoverability, identification, and contextualization across systems. This metadata allows users and machines to retrieve and interpret the ontology in a standardized way. The minimum metadata recommeded is:\n\n1) Ontology identification and description:\n- Ontology name\n- Ontology main namespace URI \n- Ontology preferred prefix: A recommended prefix established by the authors to used by other users when using their ontology. \n- Scope and description of the ontology (see Principle 2 - Scope)\n\n2) Attribution:\n- Ontology creator(s): To provide credit to the people who created the ontology. \n- Ontology contributor(s): To credit people who contribute in the ontology development, even if they didn't have a highly important role.\n- License and Copyrights rights: Indicate the conditions of (re)use of the ontology (see Principle 1 - Availability, Requirement 1 Location of the resources).\n- Citation: Indicate a way to cite the ontology. \n\n3) Versioning: \n- Version IRI of the ontology (see Principle 10 - Maintenance): The IRI that identifies the current version of the ontology.", "guidelines": [{"guideline_id": "G4.1.1", "guideline_name": "G4.1.1 What metadata used for the ontology?", "guideline_text": "G4.1.1 What metadata used for the ontology?\n\nThere are a set of well-known annotation properties from standard vocabularies that are used by the Semantic Web Community as metadata for ontologies:\n\n1) Ontology identification and description:\n\n- To declare the ontology: rdf:type  owl:Ontology\n- Ontology name: a short name of the ontology. From RDF Schema Vocabulary rdfs:label or  from DCMI Metadata Terms dtc:title \n- Ontology main namespace URI: From the VANN vocabulary vann:preferredNamespaceUri\n- Ontology preferred prefix:  From the VANN vocabulary  vann:preferredNamespacePrefix\n- Scope and description: From the DCMI Metadata Terms dct:abstract and dct:description\n\n2) Attribution: \n\n- Ontology creator: From the DCMI Metadata Terms dct:creator\n- Ontology contributor(s): From the DCMI Metadata Terms dct:contributor\n- License and Copyrights: From the DCMI Metadata Terms dct:license\n- Citation: From DCMI Metadata Terms dct:bibliographicCitation\n\n3) Versioning: \n\n- Version IRI of the ontology: From the OWL 2 Schema Vocabulary owl:versionIRI\n- To add more information of the version (e.g. the identifier): From the OWL 2 Schema Vocabulary owl:versionInfo\n- To point to external ontologies reused: From the OWL 2 Schema Vocabulary owl:imports"}]}, {"requirement_id": "R4.2", "requirement_name": "R4.2 Metadata at term level. ", "requirement_text": "R4.2 Metadata at term level. \n\nEach term in the ontology MUST include a set of metadata annotations to ensure it can be identified, understood, and reused:\n\n- A label: A descriptive and (if possible) unique human-readable name asigned to each term. \n- A textual definition: Natural language definition that facilitates the understanding of the notion. These are recommended to be unique within the ontology, and they should be avoid ambiguousity. It is also recommended that the individual name of each element must not be used in the definition itself\n- Definition source: If applicable, when the definition is extracted or adapted from another source\n- Reuse source: If the term is reused from another ontology or vocabulary, provide the URI of the original resource \n- Examples: Show examples of how the term is used in practice", "guidelines": [{"guideline_id": "G4.2.1", "guideline_name": "G4.2.1 What metadata used for describing ontology terms?", "guideline_text": "G4.2.1 What metadata used for describing ontology terms?\n\nAs the metadata for the whole ontology, there are also well-known annotations for the terms individually:\n\n- Label:  From RDF Schema the annotation rdfs:label, used with a language tag such as @en\n- Textual definition: From RDF Schema rdfs:comment or from SKOS skos:definition. \n- Definition source: From RDF Schema rdfs:isDefinedBy\n- Resource source: From RDF Schema rdfs:isDefinedBy is also used to indicate the IRI of the ontology from which the term was reused.\n- Examples: From VANN vocabulary vann:example or from SKOS skos:example"}]}]}, {"principle_id": "P5", "principle_name": "P5 - Identifiers.", "text_principle": "P5 - Identifiers.\nThe ontology follows a clear designing policy for the creation and management of identifiers.", "requirements": [{"requirement_id": "R5.1", "requirement_name": "R5.1 Ontology and terms IRI.", "requirement_text": "R5.1 Ontology and terms IRI.\nThe ontology MUST be assigned a unique and persistent IRI to ensure its long-term accessibility. This IRI typically serves as the base for constructing the IRIs of all terms defined within the ontology.", "guidelines": [{"guideline_id": "G5.1.1", "guideline_name": "G5.1.1 Recommendations for designing and mannaging the ontology IRI", "guideline_text": "G5.1.1 Recommendations for designing and mannaging the ontology IRI"}]}, {"requirement_id": "R5.2", "requirement_name": "R5.2 Ontology versions.", "requirement_text": "R5.2 Ontology versions.\nOntology development is an iterative process in which multiple versions of the ontology are created and released. Each official version of the ontology MUST be assigned a specific and persistent IRI to ensure that users can access and cite any past version. The base ontology IRI MUST resolve to the latest available version of the ontology.\nTo do so, the ontology authors MUST define a versioning policy, including the pattern used to construct version-specific IRIs.", "guidelines": []}, {"requirement_id": "R5.3", "requirement_name": "R5.3 Naming convention.", "requirement_text": "R5.3 Naming convention.\nThe identifiers of all terms within the ontology (e.g., classes, properties, individuals), if possible, MUST be unique to avoid ambiguity and ensure clear interpretation. To support consistency and maintainability, the ontology MUST adopt a naming convention policy that defines how term identifiers are constructed.", "guidelines": []}]}, {"principle_id": "P6", "principle_name": "P6 - Reuse", "text_principle": "P6 - Reuse\nTo ensure interoperability and avoid duplication of efforts, ontologies should commit, whenever possible, to the reuse and integration of existing, well-established ontologies and vocabularies.", "requirements": [{"requirement_id": "R6.1", "requirement_name": "R6.1 Reuse of existing ontologies.", "requirement_text": "R6.1 Reuse of existing ontologies.\nWhen applicable, ontology developers MUST evaluate and reuse existing, well-established ontologies, vocabularies, or terminologies that align with the defined requirements of their ontology. Note: While it is always advisable to reuse standard well-known ontologies, vocabularies, and/or terminologies, the priority must be to select those that best align with the established requirements of your ontology and meet a minimum quality standard.", "guidelines": [{"guideline_id": "G6.1.1", "guideline_name": "G6.1.1 How to select ontologies for reuse? ", "guideline_text": "G6.1.1 How to select ontologies for reuse? \nBefore reusing existing ontologies, it is important to define what you are looking for and establish a clear selection process. The following steps can guide this activity:\n\n1) Draft a preliminary model\n\nIt is highly recommended to begin by gathering and documenting the requirements of your ontology. Then, create an initial conceptual draft that includes the main concepts you aim to represent. This early modeling step helps identify which elements may benefit from reuse.\n\n2) Search for existing resources\n\nOnce you know the types of concepts you might want to reuse, search in dedicated platforms and sources:\n\n- Ontology portals and catalogues: These platforms aggregate and publish ontologies, often offering tools to support discovery and reuse. Some are general-purpose (e.g., Linked Open Vocabularies \u2013 LOV), while others are domain-specific (e.g., AgroPortal for agriculture).\n- Scientific articles: Many ontologies are accompanied by academic publications. Searching bibliographic databases like Scopus, Web of Science, or Semantic Scholar may lead to detailed documentation and background.\n- Project-specific websites: Some ontologies are developed within the scope of specific projects and published through their official websites to increase visibility.\nExample: BIMERR ontologies.\n- Open repositories: General-purpose repositories such as Zenodo or GitHub are also commonly used to publish ontology files and associated documentation.\n\n3) Define your selection criteria\n\nGiven the vast number of existing ontologies, it is essential to establish criteria for evaluating their suitability:\n\n- Does it align with the scope and requirements of your ontology?\n- How well does it cover the domain you are modeling?\n- Is the expressivity and implementation language compatible with your own?\n- Is it licensed under open or clearly defined reuse terms?\n- Is it actively maintained (e.g., issue tracking, multiple versions)?\n- Is it supported by comprehensive and accessible documentation?\n\nFinally, in line with Principle 3 \u2013 Documentation, it is important to keep track of: 1) Where did you search for ontologies to reused, 2) Which ones were evaluated, 3) and what are the elements you are going to reused."}, {"guideline_id": "G6.1.2", "guideline_name": "G6.1.2  How to reuse ontologies in practice", "guideline_text": "G6.1.2  How to reuse ontologies in practice\n\nOnce you\u2019ve identified a suitable ontology, there are two main approaches to reuse it in your own ontology:\n\nA) Hard reuse - The whole ontology is imported in your ontology. To do so, here are some points to take in mind: \n\n- If the ontology is in OWL, then the OWL construct owl:imports must be used with the IRI of the ontology. \n- Make sure to import a stable IRI, ideally a version-specific IRI to avoid unintended updates.\n- If you use the base IRI, be aware that updates in the original ontology will be reflected in yours.\n\nExample: \n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n\n<https://w3id.org/example> rdf:type owl:Ontology ;\n                                            owl:imports <http://w3id.org/example2> .\n\n\nB) Soft reuse - Individual terms or collection of terms are reused but no the whole ontology: \n\n- The terms are referenced by reusing their IRIs. This allows more control and stability, as your ontology is not automatically affected by changes in the source ontology.\n- It is important to document the source of the reused terms using the annotation property rdfs:isDefinedBy to indicate the IRI of the original ontology. \n\nExample: \n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix ex: <https://w3id.org/example> . \n\n<http://purl.obolibrary.org/obo/SO_0000704>  rdf:type owl:Class ;\n                  rdfs:label \"Gene\"@en ;\n                  rdfs:isDefinedBy <http://purl.obolibrary.org/obo/so.owl> ."}]}]}, {"principle_id": "P7", "principle_name": "P7 -  Modularity.", "text_principle": "P7 -  Modularity.\nTo facilitate maintenance and reusability, ontologies are modularized whenever possible. A single reference ontology is developed to cover a specific domain of knowledge. This ontology functions as an independent module, while also being able to integrate with other modules that, together, form a coherent network of ontologies.", "requirements": [{"requirement_id": "R7.1", "requirement_name": "R7.1 Scope and coverage.", "requirement_text": "R7.1 Scope and coverage.\nTo support modular ontology development and prevent overlapping, the scope and coverage of each module MUST be clearly defined from the beginning of the ontology design process. This facilitates the identification of independent but complementary modules and ensures that each one contributes to a coherent and non-redundant ontology network.", "guidelines": []}]}, {"principle_id": "P8", "principle_name": "P8 - Format ", "text_principle": "P8 - Format \nThe ontology is made available in at least one standard knowledge representation language, to ensure its interpretability and interoperability by tools, systems, and users.", "requirements": [{"requirement_id": "R8.1", "requirement_name": "R8.1 Ontology language.", "requirement_text": "R8.1 Ontology language.\nThe ontology MUST be encoded and made available in one or more standard formal representation languages", "guidelines": [{"guideline_id": "G8.1.1", "guideline_name": "G8.1.1 What representation language can I choose for my ontology?", "guideline_text": "G8.1.1 What representation language can I choose for my ontology?\n\nChoosing a suitable formal language is essential to ensure that the ontology can be interpreted, shared, and reused across tools and systems. The choice depends on the ontology\u2019s purpose, level of expressiveness required, and target users. Once all of this has been decided, there are well-know W3C standards representation languages widely used by the Semantic Web Community:\n\n- RDF(S) (Resource Description Framework and RDF Schema): RDF is the foundational data model for representing information as subject-predicate-object triples. RDF Schema (RDFS) extends RDF with basic schema capabilities (e.g., classes, subclasses, domains, and ranges). While not highly expressive, RDF(S) is widely supported and often sufficient for metadata,  and lightweight ontologies.\n- OWL (Web Ontology Language): Highly expressive and ideal for complex logic-based modeling and reasoning.\n\n \n- SKOS  (Simple Knowledge Organization System): A lightweight language designed to represent controlled vocabularies such as taxonomies and thesauri. It is ideal for simpler hierarchies where formal logic is not required.\n\nNote: In the biomedical domain, it is also common to use the OBO format. While not a formal ontology language, it is human-readable and commonly used by OBO Foundry ontologies. However, it has less expressivity than OWL.\n\nOWL and RDF-based ontologies can be serialized in various format:\n\n- Turtle (.ttl): A compact and human-readable syntax.\n- RDF/XML (.rdf): XML-based syntax. Less human-friendly, but still used by a wide range of systems. \n- JSON-LD (.jsonld): JSON-based syntax, ideal for web-based applications. \n- N-Triples / N-Quads: used for data dumps or high-performance processing\n\nHowever, offering multiple of these serializations is always a good practice. \n\nThere are many tools that support the development of ontologies in different representation languages and export in various formats:\n\n- Prot\u00e9g\u00e9: The most widely used open-source ontology editor. Supports OWL, RDF(S), and multiple serializations. Offers reasoning and validation plugins.\n- Chowlk: A tool that converts UML-based ontology conceptualizations to OWL code. Really helpfull for ontology engineers that prefer to edit on the diagram that in the code.  \n- Ontology Development Kit (ODK): A toolkit designed for developing ontologies in OBO format with support for lifecycle management, release pipelines, and validation.\n- VocBench: A web-based platform for collaborative development and management of RDF, SKOS, and OWL ontologies.\n- Fluent Editor: A commercial tool that allows editing OWL ontologies using a controlled natural language interface."}]}]}, {"principle_id": "P9", "principle_name": "P9 - Adoption.", "text_principle": "P9 - Adoption.\nTo ensure the impact and relevance of an ontology, its adoption by the intended users is actively promoted and monitored.", "requirements": [{"requirement_id": "R9.1", "requirement_name": "R9.1 Adoption by community.", "requirement_text": "R9.1 Adoption by community.\nThere SHOULD be a set of indicators that demonstrate the ontology is being used by its intended community. These indicators not only reflect the level of adoption, but can also serve for assessing the ontology\u2019s quality.", "guidelines": [{"guideline_id": "G9.1.1", "guideline_name": "G9.1.1 Indicators of the ontology's use", "guideline_text": "G9.1.1 Indicators of the ontology's use\n\nTo assess whether an ontology is being adopted by its target community, it is recommended to monitor and document a set of usage indicators. These indicators help measure adoption levels and provide valuable feedback for ontology maintainers and evaluators.\n\nCommon indicators include:\n\n- Change and issue tracking activity: Record user contributions, issue reports, and suggestions using tools such as GitHub, GitLab, mailing lists, or issue trackers. \n\n- Scientific and technical citations: Track how often the ontology (or the publications describing it) is cited in scientific articles, technical reports, or other ontologies.\n\n- Ontology-based data annotation: Identify datasets that use the ontology to annotate or structure data. It is recommended to identify how and where ontology terms are applied in practice.\n\n- Integration in projects: Highlight use of the ontology in research projects, tools, platforms, or softwares. Include references to project websites, deliverables, or documentation where the ontology's role is explicitly mentioned.\n\nIt is a good practice to reviewed these kind of indicators periodically as part of the ontology's lifecycle management."}]}, {"requirement_id": "R9.2", "requirement_name": "R9.2 Dissemination.", "requirement_text": "R9.2 Dissemination.\nTo promote the adoption and use of the ontology, it is recommended that the authors prepare a set of dissemination activities and supporting materials. These should explain how to use, access, and collaborate with the ontology resources. The materials SHOULD be adapted to the profile and needs of the target user groups.", "guidelines": [{"guideline_id": "G9.2.1", "guideline_name": "G9.2.1 Dissemination activities and materials", "guideline_text": "G9.2.1 Dissemination activities and materials\n\nTo promote the adoption and reuse of an ontology, it is important to actively disseminate the ontology and support users with clear and accessible educational materials. These resources should be tailored to the target audiences and aligned with the ontology\u2019s intended use.\n\nRecommended dissemination activities and materials include:\n\n- Tutorials and demos: Provide interactive or step-by-step guides that explain how to access, explore, and use the ontology, including how to query it using tools such as SPARQL.\n- Scientific publications: Publish research articles, conference papers, or technical reports that describe the ontology\u2019s development, scope, and use cases. These publications enhance the ontology\u2019s visibility within the community.\n- Webinars and workshops: Organize or participate in events to present the ontology to potential adopters. These formats allow for live demonstrations and direct interaction with users."}]}]}, {"principle_id": "P10", "principle_name": "P10 - Maintenance.", "text_principle": "P10 - Maintenance.\nTo ensure the long-term relevance, accuracy, and usability of an ontology, its resources are regularly reviewed and updated to incorporate new requirements, corrections, and improvements.", "requirements": [{"requirement_id": "R10.1", "requirement_name": "R10.1 Ontology evolution.", "requirement_text": "R10.1 Ontology evolution.\n\nOntologies are not static resources, they evolve over time to incorporate new requirements, correct errors, and adapt to changing knowledge domains. To manage this process effectively, ontology owners MUST define a clear evolution strategy. This includes establishing guidelines and procedures for managing changes, documenting decisions, and involving stakeholders.", "guidelines": [{"guideline_id": "G10.1.1", "guideline_name": "G10.1.1 Ontology evolution", "guideline_text": "G10.1.1 Ontology evolution\n\nAs ontologies are used to represent dynamic and evolving domains, managing changes in a controlled and transparent way remains an ongoing research challenge. While there are many approaches under development, ontology owners can already follow a set of essential practices to define a basic strategy for monitoring and managing the evolution of their ontology over time:\n\n1. Monitoring the changes\n\nOntology owners should continuously monitor the evolution of the domain the ontology represents. This includes:\n\n- Tracking changes in scientific consensus, terminology, or standards.\n- Engaging with domain experts to detect new requirements or corrections.\n- Retrieve the users' feedback, and open issues from collaborative platforms such as GitHub or mailing lists.\n\n2. Define a changes managing strategy\n\nA minimal strategy should include the types of changes that are expected and how to handle them. The most common changes normally are:\n\n- Obsoletion of terms: When a term becomes obsolete it is a good practice is to mark them as deprecated using the owl:deprecated \"true\" and provide replacement suggestions when possible.\n- Modification of terms (or axioms): Updating the labels, textual definitions, or properties.\n- Addition of new terms: Introduce new concepts or relationships as the scope and/or the requirements of the ontology change or expand.\n\n3. Document changes and decisions\n\nEvery change made to the ontology should be documented for transparency and traceability:\n\n- Include the reason for the change.\n- Keep a changelog file or detailed release notes to promote traceability (e.g., in CHANGELOG.md or GitHub Releases).\n- Reference related issues, discussions, or requests when applicable.\n\nThe evolution processes should be aligned with the versioning policies and be properly communicated to users (see Principle 5 \u2013 Identifiers, R10.2 Users Communication, and R10.3 Versioning)."}]}, {"requirement_id": "R10.2", "requirement_name": "R10.2 Users communication.", "requirement_text": "R10.2 Users communication.\nThere MUST be defined communication channels to facilitate the interaction between the ontology owners and its users or community. These channels enable users to report issues, request changes, or provide feedback, and allow ontology owners to notify users about updates, new releases, or important decisions.", "guidelines": [{"guideline_id": "G10.2.1", "guideline_name": "G10.2.1 Users Communication", "guideline_text": "G10.2.1 Users Communication\n\nCommunication channels are essential to keep users informed throughout the lifecycle of the ontology. Recommended communication mechanisms include:\n\n1) Issue trackers: Use issue tracking systems (e.g., GitHub Issues, GitLab) to allow users to report bugs, request new features, or having discussions regarding the ontology.\n\n2) Define and create communication channels: Keep the community informed about changes through:\n - Mailing lists or newsletters\n - Social media channels\n - Dedicated pages on the project\u2019s website\n - Release notes or changelog files in the repository (e.g., CHANGELOG.md, GitHub Releases)\n\nIt's important to clearly indicate how users can access these channels (e.g., through links in the ontology documentation or metadata) and to ensure their maintenance over time."}]}, {"requirement_id": "R10.3", "requirement_name": "R10.3 Versioning.", "requirement_text": "R10.3 Versioning.\nA versioning protocol is essential to ensure the traceability and long-term management of the ontology. It allows both users and maintainers to track the evolution of the ontology across time. For that, ontology owners MUST define a clear versioning strategy that includes:\n\n- The use of unique and persistent identifiers (IRIs) to each released version (see Principle 5 \u2013 Identifiers).\n- The storage and accessibility of versioned files, ensuring that each version remains available even after new versions are released.", "guidelines": [{"guideline_id": "G10.3.1", "guideline_name": "G10.3.1 Versioning", "guideline_text": "G10.3.1 Versioning\n\nOntology versioning is essential to ensure that users can trace the evolution of the ontology and understand what has changed across versions. The following practices support effective versioning management:\n\n1. Assign persistent version identifiers\n\nEach official version of the ontology should have a unique and stable IRI. It is recommended to adopt a versioning pattern (e.g., semantic versioning v1.0.0) and consistently apply it to all published versions (see Principle 5 - Identifiers).\n\n2. Maintain a changelog\n\nA CHANGELOG.md file or equivalent release notes should be maintained in the version control system (e.g., GitHub). This file should clearly record:\n\n- The date of each release\n- A summary of the changes \n- Contributors involved in the changes\n\n3. Preserve previous versions\n\nMake previous ontology versions accessible. Avoid deleting or overwriting old versions, as they may be still used by external systems.\n\n4. Synchronize documentation and metadata\n\nThe documentation and the ontology metadata must reflect the current version and the changes. Remember to update:\n\n- The metadata using the annotations owl:versionIRI and owl:versionInfo\n- The diagrams, requirements, queries, and usage examples"}]}, {"requirement_id": "R10.4", "requirement_name": "R10.4 Contribution/Collaboration guidelines.", "requirement_text": "R10.4 Contribution/Collaboration guidelines.\nIf the ontology is open to external contributions, the ontology owners MUST provide clear and accessible guidelines for collaboration. These guidelines ensure that contributions are well-managed and align with the ontology\u2019s objectives.", "guidelines": [{"guideline_id": "G10.4.1", "guideline_name": "G10.4.1 Contribution guidelines ", "guideline_text": "G10.4.1 Contribution guidelines \n\nThe contribution guidelines should explain how external users and stakeholders can participate in the maintenance and evolution of the ontology. The recommended elements to include are:\n\n1) Contribution scope - Clarify the types of contributions that are welcomed. These may include:\n- Reviewing and suggesting edits to class or property definitions\n- Proposing new terms or modifications\n- Contributing to documentation or examples\n- Reporting issues or inconsistencies\n\n2) Processes and communication channels - Explain the procedures contributors should follow for each type of input. For example:\n- Technical feedback might be submitted via issue trackers (e.g., GitHub Issues)\n- General suggestions or community feedback might be collected via online forms or mailing lists\n\nSee example: The Financial Industry Business Ontology (FIBO) provides a CONTRIBUTING.md file in its GitHub repository outlining how community members can participate."}]}]}];

    function render() {
      const container = document.getElementById("content");
      governanceModel.forEach(principle => {
        const pDiv = document.createElement("div");
        pDiv.className = "principle";

        const pHeader = document.createElement("div");
        pHeader.className = "principle-header";
        pHeader.innerHTML = `
          <div class="checkbox-container">
            <input type="checkbox">
          </div>
          <span>${principle.principle_name}</span>
          <span class="arrow">▼</span>
        `;

        const pContent = document.createElement("div");
        pContent.className = "principle-content";
        pContent.innerHTML = `<p>${principle.text_principle}</p>`;

        principle.requirements.forEach(req => {
          const rDiv = document.createElement("div");
          rDiv.className = "requirement";

          const rHeader = document.createElement("div");
          rHeader.className = "requirement-header";
          rHeader.innerHTML = `
            <div class="checkbox-container">
              <input type="checkbox">
            </div>
            <span>${req.requirement_name}</span>
            <span class="arrow">▼</span>
          `;

          const rContent = document.createElement("div");
          rContent.className = "requirement-content";
          rContent.innerHTML = `<p>${req.requirement_text}</p>`;

          req.guidelines.forEach(g => {
            const gDiv = document.createElement("div");
            gDiv.className = "guideline";

            const gHeader = document.createElement("div");
            gHeader.className = "requirement-header";
            gHeader.innerHTML = `
              <div class="checkbox-container">
                <input type="checkbox">
              </div>
              <span>${g.guideline_name}</span>
              <span class="arrow">▼</span>
            `;

            const gContent = document.createElement("div");
            gContent.className = "guideline-content";
            gContent.innerHTML = `<p>${g.guideline_text}</p>`;

            gDiv.appendChild(gHeader);
            gDiv.appendChild(gContent);
            rContent.appendChild(gDiv);
          });

          rDiv.appendChild(rHeader);
          rDiv.appendChild(rContent);
          pContent.appendChild(rDiv);
        });

        pDiv.appendChild(pHeader);
        pDiv.appendChild(pContent);
        container.appendChild(pDiv);
      });

      // Toggle behavior
      document.querySelectorAll(".principle-header").forEach(header => {
        header.addEventListener("click", function (e) {
          if (e.target.tagName !== "INPUT") {
            const content = this.nextElementSibling;
            const arrow = this.querySelector(".arrow");
            content.style.display = content.style.display === "block" ? "none" : "block";
            arrow.classList.toggle("rotated");
          }
        });
      });

      document.querySelectorAll(".requirement-header").forEach(header => {
        header.addEventListener("click", function (e) {
          if (e.target.tagName !== "INPUT") {
            const content = this.nextElementSibling;
            const arrow = this.querySelector(".arrow");
            content.style.display = content.style.display === "block" ? "none" : "block";
            arrow.classList.toggle("rotated");
          }
        });
      });
    }

    document.addEventListener("DOMContentLoaded", render);
  </script>

<!-- Export Buttons -->
<div style="margin-top: 30px;">
  <button onclick="exportToMarkdown()">Export to Markdown</button>
  </div>

<script>
  function getSelectedContent() {
    let output = "";
    document.querySelectorAll('.principle').forEach(p => {
      const pCheckbox = p.querySelector('.principle-header input[type=checkbox]');
      if (pCheckbox.checked) {
        output += `# ${p.querySelector('.principle-header span:nth-child(2)').innerText}\n\n`;
        output += `${p.querySelector('.principle-content > p').innerText}\n\n`;
        p.querySelectorAll('.requirement').forEach(r => {
          const rCheckbox = r.querySelector('.requirement-header input[type=checkbox]');
          if (rCheckbox.checked) {
            output += `## ${r.querySelector('.requirement-header span:nth-child(2)').innerText}\n\n`;
            output += `${r.querySelector('.requirement-content > p').innerText}\n\n`;
            r.querySelectorAll('.guideline').forEach(g => {
              const gCheckbox = g.querySelector('.requirement-header input[type=checkbox]');
              if (gCheckbox.checked) {
                output += `### ${g.querySelector('.requirement-header span:nth-child(2)').innerText}\n\n`;
                output += `${g.querySelector('.guideline-content > p').innerText}\n\n`;
              }
            });
          }
        });
      }
    });
    return output;
  }

  function exportToMarkdown() {
    const text = getSelectedContent();
    const blob = new Blob([text], { type: 'text/markdown' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'selected_governance_model.md';
    link.click();
  }

  
</script>


<script>
// Función para exportar a Markdown lo seleccionado
function exportToMarkdown() {
  let markdown = '';
  const principles = document.querySelectorAll('.principle');

  principles.forEach(principle => {
    const principleCheckbox = principle.querySelector('.principle-header input[type="checkbox"]');
    if (principleCheckbox.checked) {
      const principleTitle = principle.querySelector('.principle-header span').textContent.trim();
      const principleText = principle.querySelector('.principle-content > p')?.textContent.trim() || '';
      markdown += `# ${principleTitle}\n\n${principleText}\n\n`;

      const requirements = principle.querySelectorAll('.requirement');
      requirements.forEach(requirement => {
        const reqCheckbox = requirement.querySelector('.requirement-header input[type="checkbox"]');
        if (reqCheckbox.checked) {
          const reqTitle = requirement.querySelector('.requirement-header span').textContent.trim();
          const reqText = requirement.querySelector('.requirement-content > p')?.textContent.trim() || '';
          markdown += `## ${reqTitle}\n\n${reqText}\n\n`;

          const guidelines = requirement.querySelectorAll('.guideline');
          guidelines.forEach(guide => {
            const gCheckbox = guide.querySelector('.requirement-header input[type="checkbox"]');
            if (gCheckbox.checked) {
              const gTitle = guide.querySelector('.requirement-header span').textContent.trim();
              const gText = guide.querySelector('.guideline-content > p')?.textContent.trim() || '';
              markdown += `### ${gTitle}\n\n${gText}\n\n`;
            }
          });
        }
      });
    }
  });

  if (markdown === '') {
    alert("Please select at least one item to export.");
    return;
  }

  // Crear un archivo y disparar su descarga
  const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "governance_model.md";
  a.click();
  URL.revokeObjectURL(url);
}

// Botón de exportación
// const exportBtn = document.createElement("button");
exportBtn.textContent = "Export to Markdown";
exportBtn.style.margin = "20px 0";
exportBtn.onclick = exportToMarkdown;
document.body.insertBefore(exportBtn, document.getElementById("content"));
</script>

</body>
</html>
