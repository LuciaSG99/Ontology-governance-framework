<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ontology Governance Framework</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background-color: #ecf0f1;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .search-container {
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
        }
        
        #search-input {
            width: 100%;
            max-width: 500px;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .governance-model {
            margin-bottom: 30px;
        }
        
        .principle {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .principle-header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .principle-header.partially-fulfilled {
            background-color: #f39c12;
        }
        
        .principle-header.fulfilled {
            background-color: #2ecc71;
        }
        
        .principle-content {
            padding: 15px;
            display: none;
            background-color: #f9f9f9;
        }
        
        .requirements-list {
            list-style: none;
            padding-left: 0;
        }
        
        .requirement {
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .requirement-header {
            background-color: #3498db;
            color: white;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .requirement-content {
            padding: 15px;
            display: none;
            background-color: white;
        }
        
        .guidelines {
            margin-top: 10px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }
        
        .checkbox-container input[type="checkbox"] {
            margin-right: 5px;
            width: 18px;
            height: 18px;
        }
        
        .export-container {
            margin-top: 30px;
            text-align: center;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn-pdf {
            background-color: #e74c3c;
        }
        
        .btn-pdf:hover {
            background-color: #c0392b;
        }
        
        .btn-md {
            background-color: #2c3e50;
        }
        
        .btn-md:hover {
            background-color: #1a252f;
        }
        
        .arrow {
            transition: transform 0.3s;
        }
        
        .rotated {
            transform: rotate(180deg);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .principle-header, .requirement-header {
                padding: 10px;
            }
            
            .export-container {
                display: flex;
                flex-direction: column;
            }
            
            .btn {
                margin: 5px 0;
            }
        }
        
        /* Accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
        
        *:focus {
            outline: 3px solid #3498db;
            outline-offset: 2px;
        }
        
        /* Search result styles */
        .highlight {
            background-color: yellow;
            padding: 2px;
        }
        
        /* Footer */
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            font-size: 14px;
            color: #777;
        }
        
        /* Element titles */
        .element-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        
        .principle-title {
            font-size: 18px;
            color: white;
        }
        
        .requirement-title {
            font-size: 16px;
            color: white;
        }
        
        .guideline-title {
            font-size: 14px;
            color: #34495e;
        }
        
        /* Fix for long text in headers */
        .principle-header .principle-title,
        .requirement-header .requirement-title {
            flex: 1;
            margin-left: 10px;
            white-space: normal;
            word-break: break-word;
        }
        
        /* Component name and explanation formatting */
        .component-name {
            font-weight: bold;
            font-size: 18px;
            display: block;
            margin-bottom: 5px;
        }
        
        .component-explanation {
            font-size: 14px;
            color: white;
            display: block;
        }
        
        .requirement-name {
            font-weight: bold;
            font-size: 16px;
            display: block;
            margin-bottom: 5px;
        }
        
        .requirement-explanation {
            font-size: 13px;
            color: white;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ontology Governance Framework</h1>
            <p>Select framework elements to create your own governance model</p>
        </header>
        
        <div class="search-container">
            <input type="text" id="search-input" placeholder="Search in the framework..." aria-label="Search in the framework">
        </div>
        
        <div class="governance-model" id="governance-model">
            <!-- Content will be dynamically generated with JavaScript -->
        </div>
        
        <div class="export-container">
            <button id="export-pdf" class="btn btn-pdf">Export selection to PDF</button>
            <button id="export-md" class="btn btn-md">Export selection to Markdown</button>
        </div>
        
        <footer>
            <p>Generated on 08/04/2025 12:16:43</p>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        // Model data (generated from Excel)
        const governanceModel = [{"id": "p_p1", "name": "P1 - Availability\nThe ontology and its components (code, documentation, etc.) are available for access and consumption by the established target users, both humans and machines. \n", "requirements": [{"id": "r_r1", "name": "R1 Location of the resources\nThere MUST be defined the location where the users target will have the resources available. This location can be:\n- Ontology portal or catalogue (e.g. LOV, Bioportal)\n- Project specific web page (SAREF) \n- Git repository (FIBO)\n- Other repositories such Zenodo", "guidelines": "G1: \nPublication of ontology in Git repository: Indicate in the ontology with metadata the repository in ehich the ontology is maintained with schema:codeRepositor. "}, {"id": "r_r2", "name": "R2 Access and (re)use policies/agreements\nThere MUST be indicated what are the terms and conditions to access the ontology resources and how to (re)use them. Example: BASF", "guidelines": "G2: \nIt is recommended to indicate the access and (re)use conditions can be indicated at two levels: \nA) At the repository, or other location level, by adding for example a LICENSE document where the indications are written in a human-readable manner. For example: LINCENSE document in FIBO. \nB) At the resource level, adding it in a machine-readble manner. The most common practice is to choose a licence with an URI that is resolvable and supports content negotation. Some of the most common annotations to indicate the license are:\n- dct:license\n- dcterms:rights\n- schema:license\n- cc:license  \n"}]}, {"id": "p_p2", "name": "P2 - Scope\nThe ontology has a clearly defined scope with content that aligns with that scope to avoid overlapping with other ontologies and to facilitate discovery and selection by users. It should be specific enough to cover its intended domain while still allowing for extension and specialization.", "requirements": [{"id": "r_r1", "name": "R1: \nThe scope of the ontology should be narrow and small enough to support modularity. \n", "guidelines": ""}, {"id": "r_r2", "name": "R2\nThis scope has to be clearly and briefly stated, in any \\\"manifestation\\\" of the ontology. \n", "guidelines": "G2:\n As mentioned in the requirement, this scope should be clearly stated. For that, a good practice is to use the annotation dcterms:abstract or rdfs:comment, in which a brief and formal description of the scope and context can be add to the ontology. \n"}, {"id": "r_r3", "name": "R3\n The title/name of the ontology must be aligned with the defined scope.", "guidelines": ""}]}, {"id": "p_p3", "name": "P3 - Documentation\nTo promote transparency, traceability, and understandability, human-readable documentation of the ontology is provided. This documentation enables different users to understand all elements and procedures of the ontology lifecycle.", "requirements": [{"id": "r_r1", "name": "R1. Documentation embedded in ontology:", "guidelines": "G1:\nFor guidelines on what metadata add, see Metadata section. \n- The textual definitions can be added using skos:definition or rdfs:comment\n- If there is an adoption of a term from another ontology, there should be indicated using the annotation rdfs:isDefinedBy"}, {"id": "r_r2", "name": "R2. External documentation: ", "guidelines": "G2: \nRegarding the external documentation, it can be published as static documents (e.g. a PDF document) or interactive HTML pages. Nowadays, there are tools that support the development and publication automatically of the ontology documentation using its serialization such as: \n- Ontoology: \n- WIDOCO\n- LODE\n- Protégé OWLDoc\n- DOWL\n- SpecGen"}]}, {"id": "p_p4", "name": "P4- Metadata\nThe ontology is findable, tracked and contextualized by other users through its metadata", "requirements": [{"id": "r_r1", "name": "R1. Metadata at whole ontology level.\nThis metadata MUST be added in the header of the ontology, and it MUST include:\n- Namespaces declaration: In RDF for each namespace used in the ontology \n- The Ontology base IRI\n- Label: The ontology title\n- Abstract: A short description of the ontology, the scope. \n- Licence / Copyright terms \n- Version IRI", "guidelines": "G1\nOntology level:\n• type owl:Ontology\n• owl:versionIRI to indicate the IRI of the version\n• owl:versionInfo, to add additional with information about the version\n• owl:priorVersion, pointing to the IRI of the previous module version;\n• owl:imports that point to other reused ontologies (or modules) to import, in their specific version.\n• dcterms:title, to indicate the name of the ontology, with a language tag\n• dcterms:description, to provide more information of the ontology, with a language tag\n• dcterms:modified, which is a literal with datatype xsd:date\n• dcterms:creator: the main contributors of the ontology version\n• dcterms:contributor: other contributors of the ontology version or the repository issues\n• dcterms:license, to indicate the licence for the reuse of ontology\n• dcterms:bibliographicCitation, in case there is a publication describing the ontology. \n• vann:preferredNamespacePrefix to indicate the preferred namespace prefix to use for the ontology\n• vann:preferredNamespaceURI to indicate the preferred namespace URI to use for the ontology"}, {"id": "r_r2", "name": "R2. Metadata at term level. \nMetadata that MUST be included for each term of the ontology:\n - Preferred label\n - A textual definition\n - In case of reused from other resources, indicate the source \n - Examples of instances of the term", "guidelines": "G2\n• rdfs:label to indicate the name of the entity, with a language tag\n• rdfs:comment to add the textual definition or a additional comment about the term, with a language tag."}]}, {"id": "p_p5", "name": "P5 - Identifiers\nThe ontology follows a clear designing policy for its identifiers", "requirements": [{"id": "r_r1", "name": "R1. Ontology and terms IRI\nThe ontology MUST be assigned an unique and persistent IRI to ensure long-term accessibility. This IRI is usually used as the base of the terms of the ontology.  \n", "guidelines": "G1. "}, {"id": "r_r2", "name": "R2. Ontology versions\nThe ontology development process is a iterative cycle, in which different versions of the ontology are created. Ontology users must have access to each one of these versions, therefore each official version of the ontology MUST have assignated a specific and persistant IRI. The IRI of the ontology MUST resolve to the last version available of the ontology. To do so, the authors MUST defined a design policy on what patterns should be used to create these IRIs.", "guidelines": "G2."}, {"id": "r_r3", "name": "R3. Naming convention\nThe terms (identifiers of classes, relations) within the ontology MUST be unique, in order to avoid ambiguity and misunderstanding. To ensure this, a naming convention policy is created. ", "guidelines": "G3. "}]}, {"id": "p_p6", "name": "P6 - (Re)Usability\nTo ensure interoperability and avoid duplication, it is important to commit to (re)usability. This involves two key aspects:\n- Reuse: Whenever possible, the ontology should incorporate existing ontologies.\n- Reusability: The ontology should be designed to facilitate its reuse by other users and stakeholders.", "requirements": [{"id": "r_r1", "name": "R1. Reuse specification\nWhenever applicable, a search should be conducted for well-known ontologies to identify any existing elements that may be useful to reuse. \nNote: While it is always advisable to reuse standard well-known ontologies, vocabularies, and/or terminologies, the priority must be to select those that best align with the established requirements of your ontology and meet a minimum quality standard.", "guidelines": "G1\nIt is recommended to add in an external document a brief explanation describing which and how other ontologies are reused.\n For ontology reuse, "}]}, {"id": "p_p7", "name": "P7 -  Modularity\nTo facilitate maintenance and reusability, ontologies are modularized whenever possible. A single reference ontology is developed to cover a specific domain of knowledge. This ontology functions as an independent module while also integrating with other modules that toghether form a network of ontologies. \nNote: Here an ontology network refers to a collection of ontologies related via a variety of different meta-relationship such as mappings, modularization, version, and dependency relationships (NEON).\n ", "requirements": [{"id": "r_r1", "name": "R1. Scope and coverage\nTo avoid overlapping among ontologies, before developing the ontology, the scope and the coverage must be defined, in order to identify the modules from the beginning (see Requirement: Scope of the Ontology).", "guidelines": " Guidelines for R1. Añadir "}]}, {"id": "p_p8", "name": "P8 - Format\nThe ontology is available in at least one standard knowledge representation language. ", "requirements": [{"id": "r_r1", "name": "R1. Ontology language\nThe ontology MUST be encoded and available in one or multiple representation common formal languages", "guidelines": "Guidelines related to R1. In order to decide which representation language you are going to use, it is important to establish what your requirements are regarding the level of expressiveness of the language needed, and the use that you will give to the ontology.  The most common knowledge representation language used for ontologies are:\n1) OWL\n2) RDF(S)\n3) SKOS?\n\nNote: For ontologies of belonging to the biomedical domain, it is also common to use the OBO format. This is not a formal ontology language but a common format developed by the OBO Foundry to represent in a more human-readable manner although with less expressivity than OWL. \n\nOWL and RDF(S) can be serialized in multiple well-know syntaxis such as:\n- Turtle\n- N-triples\n- RDF/XML\n- JSON-LD\n\n There is a wide range of tools that allows you to encode and export the ontology in those formats:\n- Protégé\n- Chowlk\n- Ontology Development Kit\n- VocBench\n- Fluent Editor"}]}, {"id": "p_p9", "name": "P9 - Adoption\nPromote and check that the ontology is used and adopt by the expected users.", "requirements": [{"id": "r_r1", "name": "R1. Adoption by community\nThere should be a serie of indicators that demonstrate that the ontology is being used by the target community. These would not only served as usage indicators, but would also by used as a quality indicator. (See guidelines for examples).", "guidelines": "G1. Indicators of the usage of the resources\n- Documentation and track of the change and issue requests from users (github, mailing list, etc)\n- Citations of the ontology, and the ontology's articles. Provide link or citation in which the ontology/article is cited.  \n- Use of the ontology concepts to annotate data. Provide link to the annotation or structure\n- Use of the ontology in projects. Provide link to the project's output or/and deliverable where it shows the use of the ontology."}, {"id": "r_r2", "name": "R2. Dissemination\nIn addition, to promote the use and adoption of the ontology/ies, it is recommended that the authors prepared a set of dissemination activities and materials on how to use and collaborate within the resources. (See guidelines for examples). These materials should be adapted depending on the profile of the target user.", "guidelines": "G2. Dissemination activities and materials\n- Tutorials and demos to show how to access, use and query the ontologies\n- Scientific paper describing the development and uses cases of the ontology\n"}]}, {"id": "p_p10", "name": "P10 - Maintenance\nIn order to promote the accuracy and the use of the ontology along time, the resources are regularly checked and updated with new requirements, corrections and changes.  ", "requirements": [{"id": "r_r1", "name": "R1. Ontology evolution\nOntologies are not static resources, on the contrary, they are continuosly suffering modifications. Due to their complexity and their role in representing real-world knowledge, ontologies are frequently affected by changes and corrections. Therefore, the ontology owners MUST establish clear guidelines on how to proceeed and keep track of these changes. To do so, an ontology evolution protocol/strategy MUST be defined, establishing the different phases of evolution and the processes to follow in each phase.  AQUI INCLUIMOS LA FASE DE RECOPILACIÓN DE NUEVOS REQUISITOS? O SERÍA OTRO ELEMENTO?\n", "guidelines": "G1. Ontology evolution\n - It is recommended that the ontology owner monitors potential changes in scientific consensus. That is, assure that the knowledge represented is updated according the real world. \n- Guidelines fo ontology evolution: Paper metodología y ontologia de Diego? Paper Romana? \n     + Common changes: terms obsoletion, term modification, new terms addition. \n      \n"}, {"id": "r_r2", "name": "R2. Users/Community communication\nThere MUST be identified/defined communication channels that explains how the user targets of the ontology can communicate with the ontology owners and viceversa. This include communication of issues found/brought by the users, changes and new releases notifications", "guidelines": "G2. Users/Community Communication\n   -  Issue tracker (ej https://oa.upm.es/78277/1/SAREF4INMA.pdf, https://www.w3.org/community/schemaorg/how-we-work/issue-management-on-github/) \n   -  Channels for notifications of new releases, changes, etc.: Social media, mailing list, change log files or release notes in the Git repository"}, {"id": "r_r3", "name": "R3. Versioning \n(see Identifiers Principle) As mentioned in the Identifier principle, a versioning protocol is essential to keep the traceability of the ontology. Not only the identifiers of the different versions should be defined, but also the localization and management of the different files associated with each ontology version.", "guidelines": "G3. Versioning\n  -  Keep traceability with a CHANGELOG.md file in the Git repository.\n  - Related to Documentation, keep the documentation updated"}, {"id": "r_r4", "name": "R4. Contribution/Collaboration guidelines\n(if applies) If the ontology owners are willing to promote collaboration and to receive input from other external users, they MUST provide a set of contribution/collaboration guidelines.", "guidelines": "G4. Contribution guidelines (if applicable)\nCreate and publicate next to the rest of the ontology documentation, a document in which is explained who external users/stakeholders can collaborate in the maintenance and extension of the ontology. Example: FIBO Contributing.md file in GitHub. Within this, it is recommeded to explain:\n  - At what level can external users participate. For example, collaboration by giving input and reviewing the ontology concepts (editing textual definitions, reviewing classes and properties), giving input on the documentation, etc. \n  - In relation with the previous point, it is also recommended to explain what are the procedures to follow for each case. For example: In schema.org, for more technical-focused feedback, it is preferred to open issues on their GitHub repository, however, for other type of feedback they designed a docs google form."}]}];

        // Function to render the model
        function renderGovernanceModel() {
            const modelContainer = document.getElementById('governance-model');
            modelContainer.innerHTML = '';
            
            governanceModel.forEach(principle => {
                const principleElement = document.createElement('div');
                principleElement.className = 'principle';
                principleElement.dataset.id = principle.id;
                
                // Split principle name into name and explanation
                let principleNameParts = principle.name.split('.');
                let principleName = principleNameParts[0].trim();
                let principleExplanation = principleNameParts.slice(1).join('.').trim();
                
                const principleHeader = document.createElement('div');
                principleHeader.className = 'principle-header';
                principleHeader.innerHTML = `
                    <div class="checkbox-container">
                        <input type="checkbox" id="check-${principle.id}" class="principle-checkbox" data-id="${principle.id}" aria-label="Select principle ${principleName}">
                    </div>
                    <span class="principle-title">
                        <span class="component-name">Principle: ${principleName}</span>
                        <span class="component-explanation">${principleExplanation}</span>
                    </span>
                    <span class="arrow">▼</span>
                `;
                
                const principleContent = document.createElement('div');
                principleContent.className = 'principle-content';
                
                const requirementsList = document.createElement('ul');
                requirementsList.className = 'requirements-list';
                
                principle.requirements.forEach(requirement => {
                    const requirementItem = document.createElement('li');
                    requirementItem.className = 'requirement';
                    requirementItem.dataset.id = requirement.id;
                    
                    // Split requirement name into name and explanation
                    let requirementNameParts = requirement.name.split(':');
                    let requirementName = requirementNameParts[0].trim();
                    let requirementExplanation = requirementNameParts.length > 1 ? requirementNameParts.slice(1).join(':').trim() : '';
                    
                    const requirementHeader = document.createElement('div');
                    requirementHeader.className = 'requirement-header';
                    requirementHeader.innerHTML = `
                        <div class="checkbox-container">
                            <input type="checkbox" id="check-${requirement.id}" class="requirement-checkbox" data-principle="${principle.id}" data-id="${requirement.id}" aria-label="Select requirement ${requirementName}">
                        </div>
                        <span class="requirement-title">
                            <span class="requirement-name">Requirement: ${requirementName}</span>
                            <span class="requirement-explanation">${requirementExplanation}</span>
                        </span>
                        <span class="arrow">▼</span>
                    `;
                    
                    const requirementContent = document.createElement('div');
                    requirementContent.className = 'requirement-content';
                    
                    const guidelines = document.createElement('div');
                    guidelines.className = 'guidelines';
                    guidelines.innerHTML = `
                        <h4 class="guideline-title">Guidelines:</h4>
                        <p>${requirement.guidelines.replace(/\n/g, '<br>')}</p>
                    `;
                    
                    requirementContent.appendChild(guidelines);
                    requirementItem.appendChild(requirementHeader);
                    requirementItem.appendChild(requirementContent);
                    requirementsList.appendChild(requirementItem);
                });
                
                principleContent.appendChild(requirementsList);
                principleElement.appendChild(principleHeader);
                principleElement.appendChild(principleContent);
                modelContainer.appendChild(principleElement);
            });
            
            // Add event listeners
            addEventListeners();
        }
        
        // Function to add event listeners
        function addEventListeners() {
            // Toggle for principles
            document.querySelectorAll('.principle-header').forEach(header => {
                header.addEventListener('click', function(e) {
                    if (e.target.type !== 'checkbox') {
                        const content = this.nextElementSibling;
                        const arrow = this.querySelector('.arrow');
                        
                        content.style.display = content.style.display === 'block' ? 'none' : 'block';
                        arrow.classList.toggle('rotated');
                    }
                });
            });
            
            // Toggle for requirements
            document.querySelectorAll('.requirement-header').forEach(header => {
                header.addEventListener('click', function(e) {
                    if (e.target.type !== 'checkbox') {
                        const content = this.nextElementSibling;
                        const arrow = this.querySelector('.arrow');
                        
                        content.style.display = content.style.display === 'block' ? 'none' : 'block';
                        arrow.classList.toggle('rotated');
                    }
                });
            });
            
            // Principle checkboxes
            document.querySelectorAll('.principle-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const principleId = this.dataset.id;
                    const isChecked = this.checked;
                    
                    // Select/deselect all requirements for this principle
                    document.querySelectorAll(`.requirement-checkbox[data-principle="${principleId}"]`).forEach(reqCheckbox => {
                        reqCheckbox.checked = isChecked;
                    });
                    
                    updatePrincipleStatus();
                });
            });
            
            // Requirement checkboxes
            document.querySelectorAll('.requirement-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    updatePrincipleStatus();
                });
            });
            
            // Search
            document.getElementById('search-input').addEventListener('input', function() {
                searchModel(this.value);
            });
            
            // Export to PDF
            document.getElementById('export-pdf').addEventListener('click', function() {
                exportToPDF();
            });
            
            // Export to Markdown
            document.getElementById('export-md').addEventListener('click', function() {
                exportToMarkdown();
            });
        }
        
        // Function to update principle status (fulfilled, partially fulfilled)
        function updatePrincipleStatus() {
            governanceModel.forEach(principle => {
                const principleElement = document.querySelector(`.principle[data-id="${principle.id}"]`);
                const principleHeader = principleElement.querySelector('.principle-header');
                const principleCheckbox = document.getElementById(`check-${principle.id}`);
                
                const requirementCheckboxes = document.querySelectorAll(`.requirement-checkbox[data-principle="${principle.id}"]`);
                const totalRequirements = requirementCheckboxes.length;
                const checkedRequirements = Array.from(requirementCheckboxes).filter(cb => cb.checked).length;
                
                principleHeader.classList.remove('fulfilled', 'partially-fulfilled');
                
                if (checkedRequirements === totalRequirements && totalRequirements > 0) {
                    principleHeader.classList.add('fulfilled');
                    principleCheckbox.checked = true;
                } else if (checkedRequirements > 0) {
                    principleHeader.classList.add('partially-fulfilled');
                    principleCheckbox.checked = false;
                } else {
                    principleCheckbox.checked = false;
                }
            });
        }
        
        // Function to search in the model
        function searchModel(query) {
            if (!query) {
                // Restore normal view
                document.querySelectorAll('.principle, .requirement').forEach(el => {
                    el.style.display = '';
                });
                document.querySelectorAll('.highlight').forEach(el => {
                    const text = el.textContent;
                    el.outerHTML = text;
                });
                return;
            }
            
            query = query.toLowerCase();
            let hasResults = false;
            
            // Hide all elements first
            document.querySelectorAll('.principle, .requirement').forEach(el => {
                el.style.display = 'none';
            });
            
            // Remove previous highlights
            document.querySelectorAll('.highlight').forEach(el => {
                const text = el.textContent;
                el.outerHTML = text;
            });
            
            // Search in principles
            governanceModel.forEach(principle => {
                const principleElement = document.querySelector(`.principle[data-id="${principle.id}"]`);
                const principleText = principle.name.toLowerCase();
                let principleMatch = principleText.includes(query);
                
                // Search in requirements
                principle.requirements.forEach(requirement => {
                    const requirementElement = document.querySelector(`.requirement[data-id="${requirement.id}"]`);
                    const requirementText = requirement.name.toLowerCase();
                    const guidelinesText = requirement.guidelines.toLowerCase();
                    
                    const requirementMatch = requirementText.includes(query) || guidelinesText.includes(query);
                    
                    if (requirementMatch) {
                        requirementElement.style.display = '';
                        principleElement.style.display = '';
                        principleElement.querySelector('.principle-content').style.display = 'block';
                        requirementElement.querySelector('.requirement-content').style.display = 'block';
                        hasResults = true;
                        
                        // Highlight matching text
                        highlightText(requirementElement, query);
                    }
                });
                
                if (principleMatch) {
                    principleElement.style.display = '';
                    principleElement.querySelector('.principle-content').style.display = 'block';
                    hasResults = true;
                    
                    // Highlight matching text
                    highlightText(principleElement, query);
                }
            });
            
            if (!hasResults) {
                alert('No results found for your search.');
                // Restore normal view
                document.querySelectorAll('.principle, .requirement').forEach(el => {
                    el.style.display = '';
                });
            }
        }
        
        // Function to highlight text
        function highlightText(element, query) {
            const textNodes = getTextNodes(element);
            
            textNodes.forEach(node => {
                const text = node.nodeValue;
                const lowerText = text.toLowerCase();
                let position = lowerText.indexOf(query);
                
                if (position !== -1) {
                    const span = document.createElement('span');
                    span.className = 'highlight';
                    
                    const before = document.createTextNode(text.substring(0, position));
                    const match = document.createTextNode(text.substring(position, position + query.length));
                    const after = document.createTextNode(text.substring(position + query.length));
                    
                    span.appendChild(match);
                    
                    const parent = node.parentNode;
                    parent.insertBefore(before, node);
                    parent.insertBefore(span, node);
                    parent.insertBefore(after, node);
                    parent.removeChild(node);
                }
            });
        }
        
        // Function to get text nodes
        function getTextNodes(element) {
            const textNodes = [];
            const walk = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
            let node;
            
            while (node = walk.nextNode()) {
                if (node.nodeValue.trim() !== '') {
                    textNodes.push(node);
                }
            }
            
            return textNodes;
        }
        
        // Function to format text for Markdown
        function formatTextForMarkdown(text) {
            // Replace multiple newlines with double newlines for proper paragraph breaks
            return text.replace(/\n+/g, '\n\n').trim();
        }
        
        // Function to export to Markdown
        function exportToMarkdown() {
            let markdown = "# Ontology Governance Framework - Selection\n\n";
            let hasContent = false;
            
            governanceModel.forEach(principle => {
                const principleCheckbox = document.getElementById(`check-${principle.id}`);
                const isPrincipleSelected = principleCheckbox.checked;
                
                // Split principle name into name and explanation
                let principleNameParts = principle.name.split('.');
                let principleName = principleNameParts[0].trim();
                let principleExplanation = principleNameParts.slice(1).join('.').trim();
                
                let hasSelectedRequirements = false;
                let requirementsMarkdown = "";
                
                principle.requirements.forEach(requirement => {
                    const requirementCheckbox = document.getElementById(`check-${requirement.id}`);
                    const isRequirementSelected = requirementCheckbox && requirementCheckbox.checked;
                    
                    if (isRequirementSelected) {
                        hasSelectedRequirements = true;
                        hasContent = true;
                        
                        // Split requirement name into name and explanation
                        let requirementNameParts = requirement.name.split(':');
                        let requirementName = requirementNameParts[0].trim();
                        let requirementExplanation = requirementNameParts.length > 1 ? requirementNameParts.slice(1).join(':').trim() : '';
                        
                        requirementsMarkdown += `## Requirement: ${requirementName}\n\n`;
                        if (requirementExplanation) {
                            requirementsMarkdown += `${requirementExplanation}\n\n`;
                        }
                        
                        // Format guidelines text with proper paragraph breaks
                        const formattedGuidelines = formatTextForMarkdown(requirement.guidelines);
                        requirementsMarkdown += `### Guidelines:\n${formattedGuidelines}\n\n`;
                    }
                });
                
                if (isPrincipleSelected || hasSelectedRequirements) {
                    hasContent = true;
                    markdown += `# Principle: ${principleName}\n\n`;
                    if (principleExplanation) {
                        markdown += `${principleExplanation}\n\n`;
                    }
                    markdown += requirementsMarkdown;
                }
            });
            
            // If no content selected
            if (!hasContent) {
                markdown += "No principles or requirements have been selected.\n";
            }
            
            // Create a blob and download
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ontology_governance_framework.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Function to export to PDF
        function exportToPDF() {
            // Create a new PDF document
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            
            // Style configuration
            const pageWidth = 210;
            const margin = 20;
            const contentWidth = pageWidth - (margin * 2);
            let yPosition = 20;
            
            // Helper functions for PDF
            const addHeading = (text, level) => {
                let fontSize = 16;
                if (level === 2) fontSize = 14;
                if (level === 3) fontSize = 12;
                
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(fontSize);
                
                // Check if we need a new page
                if (yPosition > 270) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                // Split long headings into multiple lines if needed
                const lines = doc.splitTextToSize(text, contentWidth);
                doc.text(lines, margin, yPosition);
                
                // Reduced spacing after headings
                if (level === 1) {
                    yPosition += (lines.length * 7) + 2;
                    // Line under main title
                    doc.setDrawColor(0, 0, 0);
                    doc.line(margin, yPosition - 2, margin + contentWidth, yPosition - 2);
                    yPosition += 3;
                } else if (level === 2) {
                    yPosition += (lines.length * 6) + 1;
                } else {
                    yPosition += (lines.length * 5) + 1;
                }
            };
            
            const addParagraph = (text) => {
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(11);
                
                // Process text to ensure proper paragraph breaks
                const processedText = text.replace(/\n+/g, '\n\n').trim();
                
                // Split text into lines that fit content width
                const lines = doc.splitTextToSize(processedText, contentWidth);
                
                // Check if we need a new page
                if (yPosition + (lines.length * 6) > 280) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                doc.text(lines, margin, yPosition);
                
                // Calculate space needed based on actual text height with reduced spacing
                const textHeight = lines.length * 5;
                yPosition += textHeight + 5; // Reduced space after paragraphs
            };
            
            // Document title
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(20);
            doc.text('Ontology Governance Framework', pageWidth / 2, yPosition, { align: 'center' });
            yPosition += 12; // Reduced spacing
            
            // Generation date
            doc.setFont('helvetica', 'italic');
            doc.setFontSize(10);
            const today = new Date();
            const dateStr = today.toLocaleDateString();
            doc.text(`Document generated on ${dateStr}`, pageWidth / 2, yPosition, { align: 'center' });
            yPosition += 15; // Reduced spacing
            
            // Selected Principles and Requirements section
            addHeading('Selected Principles and Requirements', 1);
            
            let principleCounter = 1;
            let hasContent = false;
            
            governanceModel.forEach(principle => {
                const principleCheckbox = document.getElementById(`check-${principle.id}`);
                const isPrincipleSelected = principleCheckbox.checked;
                
                // Split principle name into name and explanation
                let principleNameParts = principle.name.split('.');
                let principleName = principleNameParts[0].trim();
                let principleExplanation = principleNameParts.slice(1).join('.').trim();
                
                // Check if there are selected requirements for this principle
                const hasSelectedRequirements = principle.requirements.some(req => {
                    const reqCheckbox = document.getElementById(`check-${req.id}`);
                    return reqCheckbox && reqCheckbox.checked;
                });
                
                if (isPrincipleSelected || hasSelectedRequirements) {
                    hasContent = true;
                    
                    // Add principle
                    addHeading(`${principleCounter}. ${principleName}`, 2);
                    
                    // Add principle explanation if available
                    if (principleExplanation) {
                        addParagraph(principleExplanation);
                    }
                    
                    principleCounter++;
                    
                    let requirementCounter = 1;
                    
                    // Add selected requirements
                    principle.requirements.forEach(requirement => {
                        const requirementCheckbox = document.getElementById(`check-${requirement.id}`);
                        const isRequirementSelected = requirementCheckbox && requirementCheckbox.checked;
                        
                        if (isRequirementSelected) {
                            // Split requirement name into name and explanation
                            let requirementNameParts = requirement.name.split(':');
                            let requirementName = requirementNameParts[0].trim();
                            let requirementExplanation = requirementNameParts.length > 1 ? requirementNameParts.slice(1).join(':').trim() : '';
                            
                            addHeading(`${principleCounter-1}.${requirementCounter}. ${requirementName}`, 3);
                            
                            // Add requirement explanation if available
                            if (requirementExplanation) {
                                addParagraph(requirementExplanation);
                            }
                            
                            requirementCounter++;
                            
                            // Add guidelines with proper formatting
                            addParagraph(`Guidelines: ${requirement.guidelines}`);
                        }
                    });
                }
            });
            
            // If no elements selected
            if (!hasContent) {
                addParagraph('No principles or requirements have been selected for this governance framework.');
            }
            
            // Footer on all pages
            const totalPages = doc.internal.getNumberOfPages();
            for (let i = 1; i <= totalPages; i++) {
                doc.setPage(i);
                doc.setFont('helvetica', 'italic');
                doc.setFontSize(8);
                doc.text(`Ontology Governance Framework - Page ${i} of ${totalPages}`, pageWidth / 2, 290, { align: 'center' });
            }
            
            // Save the PDF
            doc.save('ontology_governance_framework.pdf');
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            renderGovernanceModel();
        });
    </script>
</body>
</html>
